#+title: Project Euler in C++
#+todo: TODO SLOW SLOW-ISH | DONE TECHNICALLY-DONE
#+property: header-args :results output verbatim
#+property: header-args+ :flags (concat "-Ofast -std=gnu++17 -I" (expand-file-name "."))

* DONE p01
CLOSED: [2018-07-20 Fri 22:42]
#+begin_src C++
#include <iostream>
#include <timer.h>

int main () {
    Timer timer;
    timer.start();
    int sum = 0;
    for (int i = 3; i < 1000; ++i) {
        if ((i % 3 == 0) || (i % 5 == 0)){
            sum += i;
        }
    }
    std::cout << sum << std::endl ;
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 233168
: 0 ms

* DONE p02
CLOSED: [2018-07-20 Fri 22:42]
#+begin_src C++
#include <iostream>
#include <timer.h>

int main () {
    Timer timer;
    timer.start();
    int sum = 0;
    int oldi;
    for (int i = 1, j = 2; j <= 4000000; oldi = i, i = j, j = oldi + j) {
        if (j % 2 == 0) {
            sum += j;
        }
    }

    std::cout << sum << std::endl;
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 4613732
: 0 ms

* DONE p03
CLOSED: [2018-07-20 Fri 22:42]
#+begin_src C++
#include <iostream>
#include <cmath>
#include <timer.h>
#include <numbers.h>

int largest_prime_factor (long int n) {
    int max_factor = 1;
    for (int i = 1; i < std::sqrt(n); ++i) {
        if (n % i == 0 && small_prime_p(i)) {
            max_factor = i;
        }
    }
    return max_factor;
}
int main () {
    Timer timer;
    timer.start();
    std::cout << largest_prime_factor(600851475143) << std::endl;
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 6857
: 9 ms

* DONE p04
CLOSED: [2018-07-20 Fri 22:42]
#+begin_src C++
#include <iostream>
#include <timer.h>

bool is_palindrome(int i) {
    int n = i, reverse = 0;
    while (n != 0) {
        reverse *= 10;
        reverse += n % 10;
        n /=10;
    }
    return i == reverse;
}

int main () {
    Timer timer;
    timer.start();
    int biggest = 0;
    for (int i = 999; i > 99; --i) {
        for (int j = 999; j > 99; --j) {
            int prod = i * j;
            if (is_palindrome(prod) && prod > biggest) {
                biggest = prod;
            }

        }
    }
    std::cout << biggest << std::endl;
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 906609
: 9 ms

* DONE p05
CLOSED: [2018-07-20 Fri 22:42]
#+begin_src C++
#include <iostream>
#include <algorithm>
#include <numeric>
#include <timer.h>

int main () {
    Timer timer;
    timer.start();
    long currlcm = 1;
    for (long i = 2; i <= 20; ++i) {
        currlcm = std::lcm(i,currlcm);
    }
    std::cout << currlcm << std::endl;
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 232792560
: 0 ms

* DONE p06
CLOSED: [2018-07-20 Fri 22:42]
#+begin_src C++
#include <iostream>
#include <timer.h>

int main () {
    Timer timer;
    timer.start();
    long sum_of_squares = 0;
    long square_of_sum = 0;
    for (long i = 1; i <= 100; ++i) {
        sum_of_squares += i * i;
        square_of_sum += i;
    }
    square_of_sum *= square_of_sum;
    std::cout << square_of_sum - sum_of_squares << std::endl;
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 25164150
: 0 ms

* DONE p07
CLOSED: [2018-07-23 Mon 13:51]
#+begin_src C++
#include <iostream>
#include <timer.h>
#include <numbers.h>

int main () {
    Timer timer;
    timer.start();
    int nth_prime = 2;
    int x = 3;
    while (nth_prime < 10001) {
        x+=2;
        if (small_prime_p(x)) {
            ++nth_prime;
        }
    }
    std::cout << x << '\n';
    timer.print_elapsed();
    return 0;
}

#+end_src

#+RESULTS:
: 104743
: 3 ms

* DONE p08
CLOSED: [2018-07-20 Fri 22:42]
#+begin_src C++
#include <iostream>
#include <string>
#include <timer.h>

int main () {
    Timer timer;
    timer.start();
    std::string str =
        "73167176531330624919225119674426574742355349194934"
        "96983520312774506326239578318016984801869478851843"
        "85861560789112949495459501737958331952853208805511"
        "12540698747158523863050715693290963295227443043557"
        "66896648950445244523161731856403098711121722383113"
        "62229893423380308135336276614282806444486645238749"
        "30358907296290491560440772390713810515859307960866"
        "70172427121883998797908792274921901699720888093776"
        "65727333001053367881220235421809751254540594752243"
        "52584907711670556013604839586446706324415722155397"
        "53697817977846174064955149290862569321978468622482"
        "83972241375657056057490261407972968652414535100474"
        "82166370484403199890008895243450658541227588666881"
        "16427171479924442928230863465674813919123162824586"
        "17866458359124566529476545682848912883142607690042"
        "24219022671055626321111109370544217506941658960408"
        "07198403850962455444362981230987879927244284909188"
        "84580156166097919133875499200524063689912560717606"
        "05886116467109405077541002256983155200055935729725"
        "71636269561882670428252483600823257530420752963450";
    long max = 0;
    for (int i = 0; i <= str.length() - 13; ++i) {
        long localprod = 1;
        for (int j = i; j <= i + 12; ++j) {
            int digit = str[j] - '0';
            // std::cout << digit;
            localprod *= digit;
        }
        // std::cout << '\n';
        // std::cout << localprod << '\n';
        if (localprod > max) {
            max = localprod;
        }
    }
    std::cout << max << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 23514624000
: 0 ms

* DONE p09
CLOSED: [2018-09-05 Wed 22:02]
#+begin_src C++
#include <iostream>
#include <cmath>
#include <timer.h>

int main () {
    Timer timer;
    timer.start();
    for (long a = 1; a <= 332; ++a) {
        for (long b = a + 1; b <= 499; ++b) {
            long c_squared = a*a + b*b;
            if (c_squared == 1000000 - 2000*a - 2000*b + a*a + 2*a*b + b*b) {
                std::cout << std::fixed << int(a*b*std::sqrt(c_squared))  << '\n';
                timer.print_elapsed();
                return 0;
            }
        }
    }
    return 0;
}
#+end_src

#+RESULTS:
: 31875000
: 0 ms
* DONE p10
CLOSED: [2018-07-23 Mon 13:59]
#+begin_src C++
#include <iostream>
#include <cmath>
#include <timer.h>
#include <numbers.h>

int main () {
    Timer timer;
    timer.start();
    long sum = 0;
    for (int i = 1; i < 2000000; ++i) {
        if (small_prime_p(i)) {
            sum += i;
        }
    }
    std::cout << sum << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 142913828922
: 160 ms

* DONE p11
CLOSED: [2018-09-06 Thu 00:38]
#+begin_src C++
#include <iostream>
#include <eigen3/Eigen/Dense>
#include <string>
#include <sstream>
#include <timer.h>

long local_max(Eigen::Matrix<long,20,20> m, int i, int j) {
    Eigen::Matrix<long,4,4> subm = m.block(i,j,4,4);
    return std::max({subm.col(0).prod(),
                     subm.row(0).prod(),
                     subm.diagonal().prod(),
                     subm.rowwise().reverse().diagonal().prod()});
};

int main () {
    Timer timer;
    timer.start();
    std::string mat =
        "08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 "
        "49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 "
        "81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 "
        "52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 "
        "22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 "
        "24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 "
        "32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 "
        "67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 "
        "24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 "
        "21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 "
        "78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 "
        "16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 "
        "86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 "
        "19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 "
        "04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 "
        "88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 "
        "04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 "
        "20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 "
        "20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 "
        "01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48";
    auto m = Eigen::Matrix<long,20,20>();
    std::istringstream iss(mat);
    for (int row = 0; row < 20; ++row) {
        for (int col = 0; col < 20; ++col) {
            iss >> m(row, col);
        }
    }
    long max = 0;
    for (int i = 0; i <= 16; ++i) {
        for (int j=0; j <=16; ++j) {
            max = std::max(max, local_max(m,i,j));
        }
    }
    std::cout << max << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 70600674
: 0 ms

* DONE p12
CLOSED: [2018-07-24 Tue 00:24]
#+begin_src C++
#include <cmath>
#include <iostream>
#include <timer.h>

int num_divisors(int n) {
    int divisors = 0;
    for (int i = 1; std::pow(i,2) <= n; ++i) {
        if (n % i == 0) {
            if (n / i == i) {
                ++divisors;
            }
            else {
                divisors += 2;
            }
        }
    }
    return divisors;
}

int main () {
    Timer timer;
    timer.start();
    int num = 1;
    int tri = 1;
    while (num_divisors(tri) <= 500) {
        ++num;
        tri += num;
    }
    std::cout << tri << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 76576500
: 171 ms

* DONE p13
CLOSED: [2018-07-24 Tue 00:41]
#+begin_src C++ :libs "-lgmpxx -lgmp"
#include <iostream>
#include <gmpxx.h>
// #include <fstream>
#include <string>
#include <sstream>
#include <timer.h>

int main () {
    Timer timer;
    timer.start();
    std::string nums =
        "37107287533902102798797998220837590246510135740250 "
        "46376937677490009712648124896970078050417018260538 "
        "74324986199524741059474233309513058123726617309629 "
        "91942213363574161572522430563301811072406154908250 "
        "23067588207539346171171980310421047513778063246676 "
        "89261670696623633820136378418383684178734361726757 "
        "28112879812849979408065481931592621691275889832738 "
        "44274228917432520321923589422876796487670272189318 "
        "47451445736001306439091167216856844588711603153276 "
        "70386486105843025439939619828917593665686757934951 "
        "62176457141856560629502157223196586755079324193331 "
        "64906352462741904929101432445813822663347944758178 "
        "92575867718337217661963751590579239728245598838407 "
        "58203565325359399008402633568948830189458628227828 "
        "80181199384826282014278194139940567587151170094390 "
        "35398664372827112653829987240784473053190104293586 "
        "86515506006295864861532075273371959191420517255829 "
        "71693888707715466499115593487603532921714970056938 "
        "54370070576826684624621495650076471787294438377604 "
        "53282654108756828443191190634694037855217779295145 "
        "36123272525000296071075082563815656710885258350721 "
        "45876576172410976447339110607218265236877223636045 "
        "17423706905851860660448207621209813287860733969412 "
        "81142660418086830619328460811191061556940512689692 "
        "51934325451728388641918047049293215058642563049483 "
        "62467221648435076201727918039944693004732956340691 "
        "15732444386908125794514089057706229429197107928209 "
        "55037687525678773091862540744969844508330393682126 "
        "18336384825330154686196124348767681297534375946515 "
        "80386287592878490201521685554828717201219257766954 "
        "78182833757993103614740356856449095527097864797581 "
        "16726320100436897842553539920931837441497806860984 "
        "48403098129077791799088218795327364475675590848030 "
        "87086987551392711854517078544161852424320693150332 "
        "59959406895756536782107074926966537676326235447210 "
        "69793950679652694742597709739166693763042633987085 "
        "41052684708299085211399427365734116182760315001271 "
        "65378607361501080857009149939512557028198746004375 "
        "35829035317434717326932123578154982629742552737307 "
        "94953759765105305946966067683156574377167401875275 "
        "88902802571733229619176668713819931811048770190271 "
        "25267680276078003013678680992525463401061632866526 "
        "36270218540497705585629946580636237993140746255962 "
        "24074486908231174977792365466257246923322810917141 "
        "91430288197103288597806669760892938638285025333403 "
        "34413065578016127815921815005561868836468420090470 "
        "23053081172816430487623791969842487255036638784583 "
        "11487696932154902810424020138335124462181441773470 "
        "63783299490636259666498587618221225225512486764533 "
        "67720186971698544312419572409913959008952310058822 "
        "95548255300263520781532296796249481641953868218774 "
        "76085327132285723110424803456124867697064507995236 "
        "37774242535411291684276865538926205024910326572967 "
        "23701913275725675285653248258265463092207058596522 "
        "29798860272258331913126375147341994889534765745501 "
        "18495701454879288984856827726077713721403798879715 "
        "38298203783031473527721580348144513491373226651381 "
        "34829543829199918180278916522431027392251122869539 "
        "40957953066405232632538044100059654939159879593635 "
        "29746152185502371307642255121183693803580388584903 "
        "41698116222072977186158236678424689157993532961922 "
        "62467957194401269043877107275048102390895523597457 "
        "23189706772547915061505504953922979530901129967519 "
        "86188088225875314529584099251203829009407770775672 "
        "11306739708304724483816533873502340845647058077308 "
        "82959174767140363198008187129011875491310547126581 "
        "97623331044818386269515456334926366572897563400500 "
        "42846280183517070527831839425882145521227251250327 "
        "55121603546981200581762165212827652751691296897789 "
        "32238195734329339946437501907836945765883352399886 "
        "75506164965184775180738168837861091527357929701337 "
        "62177842752192623401942399639168044983993173312731 "
        "32924185707147349566916674687634660915035914677504 "
        "99518671430235219628894890102423325116913619626622 "
        "73267460800591547471830798392868535206946944540724 "
        "76841822524674417161514036427982273348055556214818 "
        "97142617910342598647204516893989422179826088076852 "
        "87783646182799346313767754307809363333018982642090 "
        "10848802521674670883215120185883543223812876952786 "
        "71329612474782464538636993009049310363619763878039 "
        "62184073572399794223406235393808339651327408011116 "
        "66627891981488087797941876876144230030984490851411 "
        "60661826293682836764744779239180335110989069790714 "
        "85786944089552990653640447425576083659976645795096 "
        "66024396409905389607120198219976047599490197230297 "
        "64913982680032973156037120041377903785566085089252 "
        "16730939319872750275468906903707539413042652315011 "
        "94809377245048795150954100921645863754710598436791 "
        "78639167021187492431995700641917969777599028300699 "
        "15368713711936614952811305876380278410754449733078 "
        "40789923115535562561142322423255033685442488917353 "
        "44889911501440648020369068063960672322193204149535 "
        "41503128880339536053299340368006977710650566631954 "
        "81234880673210146739058568557934581403627822703280 "
        "82616570773948327592232845941706525094512325230608 "
        "22918802058777319719839450180888072429661980811197 "
        "77158542502016545090413245809786882778948721859617 "
        "72107838435069186155435662884062257473692284509516 "
        "20849603980134001723930671666823555245252804609722 "
        "53503534226472524250874054075591789781264330331690";
    std::istringstream iss(nums);
    mpz_class sum {0};
    mpz_class n;
    while (iss >> n) {
        sum += n;
    }
    std::cout << sum.get_str().substr(0,10) << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 5537376230
: 0 ms

* DONE p14
CLOSED: [2018-07-24 Tue 01:10]
#+begin_src C++
#include <iostream>
#include <timer.h>

long collatz(long x) {
    long length {1};
    while (x != 1) {
        // std::cout << "ADING" << '\n';
        if (x % 2 == 0) {
            x /= 2;
        }
        else {
            x = 3*x + 1;
        }
        ++length;
    }
    return length;
}


int main () {
    Timer timer;
    timer.start();
    int maxlen = 0;
    int longest;
    for (int i = 1; i < 1000000; ++i) {
        int size = collatz(i);
        if (size > maxlen) {
            maxlen = size;
            longest = i;
        }
    }
    std::cout << longest  <<'\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 837799
: 235 ms

* TECHNICALLY-DONE p15
CLOSED: [2018-09-16 Sun 13:54]

40 choose 20, why or how I'm not sure - and there must be a way to get to this
programatically.
* DONE p16
CLOSED: [2018-09-06 Thu 01:35]
#+begin_src C++ :libs "-lgmpxx -lgmp"
#include <iostream>
#include <gmpxx.h>
#include <timer.h>

int main () {
    Timer timer;
    timer.start();
    mpz_class res;
    mpz_ui_pow_ui(res.get_mpz_t(),2,1000);
    int sum = 0;
    for (auto c : res.get_str()) {
        int i = c - '0';
        sum += i;
    }
    std::cout << sum << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 1366
: 0 ms

* DONE p17
CLOSED: [2018-09-06 Thu 01:54]
#+begin_src C++
#include <iostream>
#include <cmath>
#include <algorithm>
#include <timer.h>
#include <numbers.h>

std::string wordify_number(int n) {
    int i = 0;
    std::string res;
    while (! (std::pow(10, i) > n)) {
        int digit = nth_digit(n,i);
        if (i == 0 && (nth_digit(n,1) == 1)) {
            switch (digit) {
                case 0: res.insert(0, "ten"); break;
                case 1: res.insert(0, "eleven"); break;
                case 2: res.insert(0, "twelve"); break;
                case 3: res.insert(0, "thirteen"); break;
                case 4: res.insert(0, "fourteen"); break;
                case 5: res.insert(0, "fifteen"); break;
                case 6: res.insert(0, "sixteen"); break;
                case 7: res.insert(0, "seventeen"); break;
                case 8: res.insert(0, "eighteen"); break;
                case 9: res.insert(0, "nineteen"); break;
            }
        }
        else if (i != 1) {
            if (i == 2 && digit != 0) {
                res.insert(0, "hundred");
            }
            if (i == 3 && digit != 0) {
                res.insert(0, "thousand");
            }
            switch (digit) {
                case 0: break;
                case 1: res.insert(0, "one"); break;
                case 2: res.insert(0, "two"); break;
                case 3: res.insert(0, "three"); break;
                case 4: res.insert(0, "four"); break;
                case 5: res.insert(0, "five"); break;
                case 6: res.insert(0, "six"); break;
                case 7: res.insert(0, "seven"); break;
                case 8: res.insert(0, "eight"); break;
                case 9: res.insert(0, "nine"); break;
            }
            if (n >= 100 && digit != 0 && nth_digit(n,1) == 0 && i == 0) {
                res.insert(0, "and");
            }
        } else {
            switch (digit) {
                case 0: break;
                case 1: break;
                case 2: res.insert(0, "twenty"); break;
                case 3: res.insert(0, "thirty"); break;
                case 4: res.insert(0, "forty"); break;
                case 5: res.insert(0, "fifty"); break;
                case 6: res.insert(0, "sixty"); break;
                case 7: res.insert(0, "seventy"); break;
                case 8: res.insert(0, "eighty"); break;
                case 9: res.insert(0, "ninety"); break;
            }
            if (n >= 100 && digit != 0  // && nth_digit(n,2) == 0
                ) {
                res.insert(0, "and");
            }
        }
        ++i;
    }
    return res;
}

int main () {
    Timer timer;
    timer.start();
    std::string res;
    for (int i = 1; i <= 1000; ++i) {
        std::string word = wordify_number(i);
        res += word;
    }
    std::cout << res.length() << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 21113
: 0 ms

* DONE p18
CLOSED: [2018-09-06 Thu 22:19]
#+begin_src C++
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <timer.h>

typedef std::vector<std::vector<int>> triangle;

int main () {
    Timer timer;
    timer.start();
    triangle v;
    int a;
    std::ifstream f("data/p18-triangle.txt");
    for (int line = 0; line < 15; ++line) {
        std::vector<int> l;
        for (int elem = 0; elem < line + 1; ++elem) {
            int num;
            f >> num;
            l.push_back(num);
        }
        v.push_back(l);
    }
    for (triangle::reverse_iterator it = v.rbegin() + 1; it < v.rend(); ++it) {
        for (int i = 0; i < it->size(); ++i) {
            (*it)[i] += std::max((*std::prev(it))[i],(*std::prev(it))[i+1]);
        }
    }
    std::cout << v[0][0] << std::endl;
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 1074
: 0 ms

* DONE p19
CLOSED: [2018-07-27 Fri 19:58]
#+begin_src C++
#include <ctime>
#include <typeinfo>
#include <iostream>
#include <vector>
#include <timer.h>

int main () {
    Timer timer;
    timer.start();
    struct tm start_tm {0};
    strptime("1901-01-01","%Y-%m-%d",&start_tm);
    struct tm end_tm {0};
    strptime("2000-12-31","%Y-%m-%d",&end_tm);
    time_t end_seconds {mktime(&end_tm)};
    int num_sundays = 0;
    std::vector<std::string> days = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
    for (time_t s {mktime(&start_tm)}; s < end_seconds; s += 60*60*24) {
        struct tm *curr_tm {localtime(&s)};
        if (curr_tm->tm_wday == 0 && curr_tm->tm_mday == 1) {
            num_sundays += 1;
        }
    }
    std::cout << num_sundays << std::endl;
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 171
: 44 ms

* DONE p20
CLOSED: [2018-07-27 Fri 19:59]
#+begin_src C++ :libs "-O3 -lgmpxx -lgmp"
#include <iostream>
#include <gmpxx.h>
#include <numbers.h>
#include <timer.h>

mpz_class factorial(int n) {
    if (n == 0) {
        return 1;
    }
    mpz_class result {1};
    for (int i = n; i >= 1;--i) {
        result *= i;
    }
    return result;
}

int main () {
    Timer timer;
    timer.start();
    mpz_class large {factorial(100)};
    int sum {0};
    for (const auto elem : large.get_str()) {
        int i = elem - '0';
        sum += i;
    }
    std::cout << sum << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 648
: 0 ms

* DONE p21
CLOSED: [2018-07-27 Fri 21:17]
#+begin_src C++
#include <iostream>
#include <cmath>
#include <timer.h>

int d(int n) {
    int sum_divisors = 1;
    for (int i = 2; std::pow(i,2) <= n; ++i) {
        if (n % i == 0) {
            if (n / i == i) {
                sum_divisors += i;
            }
            else {
                sum_divisors += i;
                sum_divisors += n / i;
            }
        }
    }
    return sum_divisors;
}

bool is_amicable(int n) {
    int other {d(n)};
    if (other != n && d(other) == n)  {
        return true;
    }
    else { return false; }
}

int main () {
    Timer timer;
    timer.start();
    int sum_amicable = 0;
    for (int i = 2; i < 10000; ++i) {
        if (is_amicable(i)) {
            sum_amicable += i;
        }
    }
    std::cout << sum_amicable << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 31626
: 6 ms

* DONE p22
CLOSED: [2018-07-27 Fri 22:05]
#+begin_src C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <fstream>
#include <sstream>
#include <timer.h>

std::vector<std::string> split_string(std::string str,char delimiter) {
    std::vector<std::string> result;
    std::istringstream iss(str);
    std::string elem;
    while (std::getline(iss,elem,delimiter)) {
        result.push_back(elem);
    }
    return result;
};

void remove_quotes(std::string &a) {
    a = a.substr(1,a.length() - 2);
}

int main () {
    Timer timer;
    timer.start();
    std::string names_str;
    std::ifstream f("data/p22-names.txt");
    std::getline(f,names_str);
    auto vec {split_string(names_str, ',')};
    // st::vector<std::string> vec {"\"COLIN\""};
    std::for_each(vec.begin(),vec.end(),&remove_quotes);
    std::sort(vec.begin(),vec.end());
    int i {1};
    int total_score;
    for (const auto elem : vec){
        int sum_letters = 0;
        for (const auto c : elem) {
            // std::cout << c << '\n';
            int char_score = c - 64;
            sum_letters += char_score;
        }
        total_score += sum_letters * i;
        // std::cout << elem << '\n';
        ++i;
    }
    // std::string that {"\"abc\""};
    // remove_quotes(that);
    std::cout << total_score << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 871198282
: 1 ms

* DONE p23
CLOSED: [2018-09-06 Thu 01:36]
:PROPERTIES:
:ORDERED:  t
:END:
#+begin_src C++
#include <iostream>
#include <timer.h>

int pdivisor_sum(int n) {
    int sum_divisors = 1;
    for (int i = 2; i*i <= n; ++i) {
        // std::cout << i << ' ' << std::pow(i,2) << '\n';
        if (n % i == 0) {
            if (n / i == i) {
                sum_divisors += i;
            }
            else {
                // std::cout << i << ' ' << (n/i) << '\n';
                sum_divisors += i;
                sum_divisors += n / i;
            }
        }
    }
    return sum_divisors;
}

bool is_abundant(int n) {
    return pdivisor_sum(n) > n;
}

bool is_sum_of_abundant(int n) {
    for (int i = 12; i <= n/2; ++i) {
        if (is_abundant(i) && is_abundant(n - i)) {
            return true;
        }
    }
    return false;
}

int main () {
    Timer timer;
    timer.start();
    int sum = 0;
    for (int i = 0; i <= 28123; ++i) {
        if (!is_sum_of_abundat(i)) {

            sum += i;
        }
    }
    std::cout << sum << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 4179871
: 3712 ms

* DONE p24
CLOSED: [2018-07-27 Fri 23:02]
#+begin_src C++
#include <iostream>
#include <algorithm>
#include <array>
#include <timer.h>

int main () {
    Timer timer;
    timer.start();
    std::array<int,10> ints {0,1,2,3,4,5,6,7,8,9};
    int i = 1;
     while (i < 1000000) {
         std::next_permutation(ints.begin(),ints.end());
         ++i;
     }
     for (const int elem : ints) {
         std::cout << elem;
     }
     std::cout << '\n';
     timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 2783915460
: 3 ms

* DONE p25
CLOSED: [2018-07-30 Mon 00:52]
#+begin_src C++ :libs "-lgmpxx -lgmp"
#include <iostream>
#include <gmpxx.h>
#include <timer.h>

int main () {
    Timer timer;
    timer.start();
    mpz_class n {2};
    mpz_class i {1};
    mpz_class j {1};
    mpz_class fib;
    do {
        fib = i + j;
        i = j;
        j = fib;
        ++n;
    } while (fib.get_str().length() != 1000);
    std::cout << n << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 4782
: 16 ms

* DONE p26
CLOSED: [2019-01-29 Tue 11:07]
#+begin_src C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <timer.h>

int repeat_length(int num, int den) {
    std::vector<int> seen;
    do {
        int rem = num % den;
        int quo = num / den;
        if (rem == 0) {
            return 0;
        }
        auto remainder_ptr = std::find(seen.begin(), seen.end(), rem);
        if (remainder_ptr != seen.end()) {
            std::reverse(seen.begin(), seen.end());
            return remainder_ptr - seen.begin() + 1;
        } else if (quo == 0) {
            num *= 10;
            seen.push_back(rem);
        } else {
            num = (num - quo * den) * 10;
            seen.push_back(rem);
        }
    } while (true);
}

int main () {
    Timer timer;
    timer.start();
    int longest = 0;
    int len, num = 0;
    for (int d = 1; d < 1000; ++d) {
        len = repeat_length(1,d);
        if (len > longest) {
            longest = len;
            num = d;
        }
    }
    std::cout << num << std::endl;
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 768
: 7 ms

* DONE p27
CLOSED: [2019-01-29 Tue 11:37]
#+begin_src C++
#include <iostream>
#include <cmath>
#include <functional>
#include <numbers.h>
#include <timer.h>

std::function<int (int)> make_f(int a, int b) {
    return [a,b](int n){return std::pow(n,2) + a * n + b;};
}

int num_consecutive_primes(int a, int b) {
    std::function<int (int)> f = make_f(a,b);
    int n=0, primes=0;
    while(small_prime_p(f(n))) {
        n+=1;
        primes+=1;
    }
    return primes;
}

int main () {
    Timer timer;
    timer.start();
    int max_primes = 0;
    int prod;
    for(int a = -999; a < 1000; ++a) {
        for (int b = -1000; b <= 1000; ++b) {
            int consecutive = num_consecutive_primes(a,b);
            if (consecutive > max_primes) {
                max_primes = consecutive;
                prod = a * b;
            }
        }
    }
    std::cout << prod << std::endl;
    timer.print_elapsed();
}
#+end_src

#+RESULTS:
: -59231
: 54 ms

* DONE p28
CLOSED: [2019-01-29 Tue 18:22]
#+begin_src C++
#include <iostream>
#include <timer.h>

int spiral(int n) {
    int add=2, state=1;
    int sum = 0;
    while(state != n*n) {
        // int final_state = state + 4 * add;
        // std::cout << state << '\n';
        sum += 4 * state + 10 * add;
        state = state + 4 * add;
        add+=2;
    }
    return sum+1;
}

int main() {
    Timer timer;
    timer.start();
    std::cout << spiral(1001) << std::endl;
    timer.print_elapsed();
}
#+end_src

#+RESULTS:
: 669171001
: 0 ms

* DONE p29
CLOSED: [2019-01-29 Tue 18:46]
#+begin_src C++ :libs "-lgmpxx -lgmp"
#include <iostream>
#include <set>
#include <gmpxx.h>
#include <timer.h>

int main() {
    Timer timer;
    timer.start();
    int a,b;
    std::set<mpz_class> terms;
    mpz_class res;
    for(a = 2; a <= 100; ++a) {
        for (b = 2; b <= 100; ++b) {
            mpz_ui_pow_ui(res.get_mpz_t(),a,b);
            terms.insert(res);
        }
    }
    std::cout << terms.size() << std::endl;
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 9183
: 5 ms

* DONE p30
CLOSED: [2018-08-02 Thu 10:01]
#+begin_src C++
#include <iostream>
#include <cmath>
#include <timer.h>

int sum_of_fifth_powers(int n) {
    int place = 10;
    int mod;
    int sum = 0;
    do {
        mod = n % place;

        int lplace = place / 10;
        int lmod = n % lplace;

        sum += std::pow((mod - lmod)/lplace, 5);

        place *= 10;
    } while (mod != n);
    return sum;
}

int main () {
    Timer timer;
    timer.start();
    int limit;
    int i = 0;
    do {
        ++i;
        limit = std::pow(9,5) * i;
    } while (limit > std::pow(10,i) - 1);
    // std::cout << limit <<'\n';

    int sum = 0;
    for (int i = 2; i < limit; ++i) {
        if (sum_of_fifth_powers(i) == i) {
            // std::cout << i << '\n';
            sum += i;
        }
    }
    std::cout << sum << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 443839
: 23 ms

* TODO p31

* TODO p32

* DONE p33
CLOSED: [2019-01-30 Wed 12:44]
#+begin_src C++ :libs "-lgmpxx -lgmp"
#include <iostream>
#include <gmpxx.h>
#include <timer.h>

bool cancels_stupidly (mpq_class &q) {
    std::string numstr = q.get_num().get_str();
    std::string denstr = q.get_den().get_str();
    q.canonicalize();
    std::string s;
    for (int i = 0; i < 2; ++i) {
        auto ind = numstr.find(denstr[i]);
        if (ind != std::string::npos){
            s += numstr[(ind == 0 ? 1 : 0)];
            s += '/';
            char denchar = denstr[(i == 0? 1 : 0)];
            // Avoid division by zero
            if  (denchar == '0') {
                return false;
            }
            s += denchar;
            mpq_class stupidq (s);
            stupidq.canonicalize();
            return (stupidq == q);
        }
    }
    return false;
}

int main () {
    Timer timer;
    timer.start();
    mpq_class prod(1);
    for (int a = 10; a < 100; ++a) {
        for (int b = a+1; b < 100; ++b) {
            // Exclude trivial
            if (a % 10 == 0 && b % 10 ==0) {
                continue;
            }
            mpq_class q(a,b);
            if (cancels_stupidly(q)) {
                prod *= q;
            }
        }
    }
    prod.canonicalize();
    std::cout << prod.get_den() << std::endl;
    timer.print_elapsed();
}
#+end_src

#+RESULTS:
: 100
: 1 ms

* DONE p34
CLOSED: [2019-01-30 Wed 00:10]
See racket-euler - initially solved by inspection, later got a hint about limit.
#+begin_src C++ :libs "-lgmpxx -lgmp"
#include <iostream>
#include <array>
#include <gmpxx.h>
#include <numbers.h>
#include <timer.h>

mpz_class factorial_digit_sum(int n) {
    std::array<int,10> fact = {1,1,2,6,24,120,720,5040,40320,362880};
    int pow = 0;
    mpz_class res = 0;
    while (std::pow(10,pow) <= n) {
        int digit = nth_digit(n, pow);
        res += fact[digit];
        ++pow;
    }
    return res;
}

int main () {
    Timer timer;
    timer.start();
    int sum = 0;
    for (int n = 10; n < 9999999; ++n) {
        if (factorial_digit_sum(n) == n) {
            sum +=n;
        }

    }
    std::cout << sum << std::endl;
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 40730
: 2101 ms

* DONE p35
CLOSED: [2018-08-06 Mon 18:05]
#+begin_src C++
#include <iostream>
#include <string>
#include <algorithm>
#include <numbers.h>
#include <timer.h>

int circular_prime(int x) {
    std::string s {std::to_string(x)};
    if (!small_prime_p(x)) {
        return 0;
    }
    for (int i = 1; i < s.length(); ++i) {
        std::rotate(s.begin(),s.begin()+1,s.end());
        if (!small_prime_p(std::stoi(s))) {
            return 0;
        }
    }
    return 1;
}

int main () {
    Timer timer;
    timer.start();
    int count = 0;
    for (int i = 0; i < 1000000; ++i) {
        count += circular_prime(i);
    }
    std::cout << count << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 55
: 147 ms

* DONE p36
CLOSED: [2018-08-07 Tue 07:49]
#+begin_src C++
#include <iostream>
#include <string>
#include <bitset>
#include <timer.h>

bool bipalindromic (int x) {
    std::string s { std::to_string(x) };
    std::string bs {std::bitset<32>(x).to_string()};
    bs.erase(0,bs.find_first_not_of("0"));
    // std::cout << bs << '\n';
    if (s == std::string(s.rbegin(), s.rend())
        && bs == std::string(bs.rbegin(), bs.rend())) {
        return true;
    }
    return false;
}

int main () {
    Timer timer;
    timer.start();
    int sum = 0;
    for (int i = 0; i < 1000000; ++i) {
        if (bipalindromic(i)) {
            sum += i;
        }
    }
    std::cout << sum << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 872187
: 199 ms

* DONE p37
CLOSED: [2018-08-07 Tue 08:07]
#+begin_src C++
#include <iostream>
#include <cmath>
#include <string>
#include <numbers.h>
#include <timer.h>

bool truncatable_prime(int x) {
    if (small_prime_p(x)) {
        std::string s {std::to_string(x)};
        for (int i = 1; i < s.length(); ++i) {
            if (!small_prime_p(std::stoi(s.substr(i, s.length())))
                || !small_prime_p(std::stoi(s.substr(0, s.length() - i)))) {
                return false;
            }
        }
        return true;
    }
    return false;
}

int main () {
    Timer timer;
    timer.start();
    int count = 0, sum = 0;
    int i = 11;
    while (count != 11) {
        if (truncatable_prime(i)) {
            sum += i;
            ++count;
        }
        ++i;
    }
    std::cout << sum << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 748317
: 58 ms

* DONE p38
CLOSED: [2019-01-31 Thu 11:17]
#+begin_src C++
#include <iostream>
#include <string>
#include <algorithm>
#include <timer.h>

bool special(int n) {
    std::string s = std::to_string(n);
    std::string tmp, res;
    int i = 1;
    do {
        tmp = s.substr(0,i);
        int num = std::stoi(tmp);
        int j = 2;
        res = tmp;
        while(std::stol(res) < n) {
            res += std::to_string(j*num);
            ++j;
        }
        if (std::stol(res) == n) {
            return true;
        }
        ++i;
    } while(std::stol(res) != n && i <= 4);
    return false;
}

int main() {
    Timer timer;
    timer.start();
    std::string pan = "987654321";
    do {
        if (special(std::stol(pan))) {
            std::cout << pan << std::endl;
            timer.print_elapsed();
            return 0;
        }
    } while (std::prev_permutation(pan.begin(),pan.end()));
    return 0;
}
#+end_src

#+RESULTS:
: 932718654
: 59 ms

* DONE p39
CLOSED: [2018-09-05 Wed 04:27]
#+begin_src C++
#include <iostream>
#include <cmath>
#include <vector>
#include <array>
#include <algorithm>
#include <timer.h>

typedef std::array<int,3> soln;

bool test_triangle(int P, int a, int b) {
    return P == (a + b) + sqrt(a*a + b*b);
}

std::vector<soln> solve_triangle(int P) {
    std::vector<soln> res;
    for (int a=1; a <= 998; ++a) {
        for (int b = a; b <= 998; ++b) {
            int c = sqrt(a*a + b*b);
            if (test_triangle(P, a, b)) {
                res.push_back(soln{a,b,c});
            }
        }
    }
    return res;
}

void print_soln (soln v) {
    std::cout << "{";
    for (auto it = v.begin(); it != v.end() - 1; ++it) {
        std::cout << *it << ' ';
    }
    std::cout << *(v.end() - 1) << '}' << '\n';
}

int main () {
    Timer timer;
    timer.start();
    int r = 0;
    std::vector<soln> solutions;
    int len = 0;
    for (int i = 4; i <= 1000; ++i) {
        solutions = solve_triangle(i);
        if (solutions.size() > len) {
            len = solutions.size();
            r = i;
        }
    }
    std::cout << r << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 840
: 896 ms

* DONE p40
CLOSED: [2018-09-05 Wed 19:53]
#+begin_src C++
#include <iostream>
#include <string>
#include <timer.h>

int char2int(char c) {
    int i = c - '0';
    return i;
}

int main () {
    Timer timer;
    timer.start();
    std::string digits;
    int i = 1;
    do {
        digits += std::to_string(i);
        ++i;
    } while (digits.length() < 1000000);
    std::cout << char2int(digits[0])
        ,* char2int(digits[9])
        ,* char2int(digits[99])
        ,* char2int(digits[999])
        ,* char2int(digits[9999])
        ,* char2int(digits[99999])
        ,* char2int(digits[999999])
              << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 210
: 19 ms

* DONE p41
CLOSED: [2019-01-30 Wed 13:18]
#+begin_src C++
#include <iostream>
#include <string>
#include <algorithm>
#include <numbers.h>
#include <timer.h>

int main() {
    Timer timer;
    timer.start();
    std::string s = "987654321";
    std::string substr;
    for (int i = 0; i < 9; ++i) {
        substr = s.substr(i,9);
        do {
            if (small_prime_p(std::stoi(substr))) {
                std::cout << substr << std::endl;
                timer.print_elapsed();
                return 0;
            }
        } while (std::prev_permutation(substr.begin(),substr.end()));
    }
    return 0;
}
#+end_src

#+RESULTS:
: 7652413
: 13 ms

* DONE p42
CLOSED: [2019-01-30 Wed 14:35]
#+begin_src C++
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <timer.h>

std::vector<std::string> split_file(const std::string &s, char delimiter) {
    std::ifstream f(s);
    std::vector<std::string> result;
    std::string elem;
    while (std::getline(f,elem,delimiter)) {
        result.push_back(elem);
    }
    return result;
};

bool triangle_p (int n) {
    double intpart;
    return modf(.5*(-1 + std::sqrt(1 + 8*n)),&intpart) == 0.0;
}

int word_score(std::string const &word) {
    int sum = 0;
    for (const char letter : word) {
        sum += letter - 'A' + 1;
    }
    return sum;
}

int main() {
    Timer timer;
    timer.start();
    int num = 0;
    std::vector<std::string> words = split_file("data/p42-words.txt",',');
    for (auto &elem : words) {
        elem.erase(elem.find_last_not_of('"')+1);
        elem.erase(0,elem.find_first_not_of('"'));
        int score = word_score(elem);
        if (triangle_p(score)) {
            ++num;
        }
    }
    std::cout << num << std::endl;
    timer.print_elapsed();
}
#+end_src

#+RESULTS:
: 162
: 0 ms

* DONE p43
CLOSED: [2019-01-31 Thu 14:08]
#+begin_src C++
#include <iostream>
#include <string>
#include <algorithm>
#include <timer.h>

bool special(std::string s) {
    return (std::stoi(s.substr(1,3)) % 2 == 0
            && std::stoi(s.substr(2,3)) % 3 == 0
            && std::stoi(s.substr(3,3)) % 5 == 0
            && std::stoi(s.substr(4,3)) % 7 == 0
            && std::stoi(s.substr(5,3)) % 11 == 0
            && std::stoi(s.substr(6,3)) % 13 == 0
            && std::stoi(s.substr(7,3)) % 17 == 0);
}

int main () {
    Timer timer;
    timer.start();
    std::string s = "9876543210";
    long sum = 0;
    do {
        if (special(s)) {
            sum += std::stol(s);
        }
    } while (std::prev_permutation(s.begin(),s.end()));
    std::cout << sum << std::endl;
    timer.print_elapsed();
}
#+end_src

#+RESULTS:
: 16695334890
: 167 ms

* TODO p44

* DONE p45
CLOSED: [2019-01-31 Thu 14:39]
#+begin_src C++
#include <iostream>
#include <cmath>
#include <timer.h>

long nth_triangle(long n) {
    return (n * (n + 1)) / 2;
}

bool pentagonal_p (double n) {
    double intpart;
    return modf((1 + std::sqrt(1 + 24*n)) / 6,&intpart) == 0.0;
}

bool hexagonal_p (double n) {
    double intpart;
    return modf(.25*(1 + std::sqrt(1 + 8*n)),&intpart) == 0.0;
}

int main() {
    Timer timer;
    timer.start();
    long i = 285;
    long tri;
    do {
        ++i;
        tri = nth_triangle(i);
    } while (!(pentagonal_p(tri) && hexagonal_p(tri)));
    std::cout << tri << std::endl;
    timer.print_elapsed();
}
#+end_src

#+RESULTS:
: 1533776805
: 0 ms

* TODO p46
#+begin_src C++
#include <iostream>
#include <numbers.h>

bool goldbach_composite_p(int n) {

}
#+end_src

* p47
#+begin_src C++
#+end_src
* TODO p49
#+begin_src C++
#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>
#include <numbers.h>

std::vector<std::string> get_prime_permutations(int n) {
    std::vector<std::string> v;
    std::string a = std::to_string(n);
    do {
        int num = std::stoi(a);
        if (small_prime_p(num)) {
            v.push_back(a);
        }
    } while (std::next_permutation(a.begin(), a.end()));
    return v;
}

int main () {
    auto v = get_prime_permutations(1487);
    for (const auto elem : v) {
        std::cout << elem << '\n';
    }
    // for (int i = 1000; i < 10000; ++i) {
    //     bool special = true;
    //     std::vector<std::string> v = get_prime_permutations(i);
    //     if (v.size() == 3) {
    //         std::cout << i << '\n';
    //     }
    // }
    return 0;
}
#+end_src

#+RESULTS:
: 1487
: 1847
: 4817
: 4871
: 7481
: 7841
: 8147
: 8741

* TODO p50

* TODO p51

* DONE p52
CLOSED: [2019-01-30 Wed 16:19]
#+begin_src C++
#include <iostream>
#include <algorithm>
#include <string>
#include <timer.h>

bool special(int n) {
    std::string s = std::to_string(n);
    auto begin = s.begin();
    auto end = s.end();
    std::string s2 = std::to_string(2*n);
    std::string s3 = std::to_string(3*n);
    std::string s4 = std::to_string(4*n);
    std::string s5 = std::to_string(5*n);
    std::string s6 = std::to_string(6*n);
    return (is_permutation(begin,end, s2.begin())
            && is_permutation(begin,end, s3.begin())
            && is_permutation(begin,end, s4.begin())
            && is_permutation(begin,end, s5.begin())
            && is_permutation(begin,end, s6.begin()));

}

int main () {
    Timer timer;
    timer.start();
    int i = 123;
    while (!special(i)) {
        ++i;
    }
    std::cout << i << std::endl;
    timer.print_elapsed();
}
#+end_src

#+RESULTS:
: 142857
: 69 ms

* DONE p53
CLOSED: [2019-01-30 Wed 22:31]
#+begin_src C++
#include <iostream>
#include <numbers.h>
#include <timer.h>

int binomial_over_million(double n) {
    double k = 1;
    int res = 0;
    while (k < n + 1) {
        if (binomial_coefficient(n,k) > 1000000) {
            // std::cout << k << '\n';
            ++res;
        }
        ++k;
    }
    return res;
}

int main () {
    Timer timer;
    timer.start();
    int count = 0;
    for (int i = 1; i <= 100; ++i) {
        count += binomial_over_million(i);
    }
    std::cout << count << std::endl;
    timer.print_elapsed();
}
#+end_src

#+RESULTS:
: 4075
: 0 ms

* TODO p54

* DONE p55
CLOSED: [2019-01-30 Wed 23:17]
#+begin_src C++ :libs "-lgmpxx -lgmp"
#include <iostream>
#include <algorithm>
#include <string>
#include <cstring>
#include <cstdio>
#include <gmpxx.h>
#include <timer.h>

bool is_palindrome_p(const char *s) {
    for (int i=0,j=strlen(s)-1;j>=0; ++i, --j) {
        if (s[i] != s[j]) {
            return false;
        }
    }
    return true;
}

bool lychrel_p(mpz_class n) {
    std::string s;
    for (int i = 0; i < 50; ++i) {
        s = n.get_str();
        std::reverse(s.begin(),s.end());
        s.erase(0,s.find_first_not_of('0'));
        mpz_class j {s};
        mpz_class sum {n + j};
        if (is_palindrome_p(sum.get_str().c_str())) {
            return false;
        }
        n = sum;
    }
    return true;
}

int main() {
    Timer timer;
    timer.start();
    int count = 0;
    for (int i = 1; i < 10000; ++i) {
        if (lychrel_p(i)) {
            ++count;
        }
    }
    std::cout << count << std::endl;
    timer.print_elapsed();
}
#+end_src

#+RESULTS:
: 249
: 18 ms

* DONE p56
CLOSED: [2019-01-31 Thu 00:19]
#+begin_src C++ :libs "-lgmpxx -lgmp"
#include <iostream>
#include <gmpxx.h>
#include <timer.h>

int digital_sum(const mpz_class &z) {
    int sum = 0;
    for (const auto elem : z.get_str()) {
        sum += elem - '0';
    }
    return sum;
}

int main() {
    Timer timer;
    timer.start();
    int sum;
    mpz_class exp;
    int max = 0;
    // mpz_ui_pow_ui(exp.get_mpz_t(), 99, 95);
    // sum = digital_sum(exp);
    for (int a = 0; a < 100; ++a) {
        for (int b = 0; b < 100; ++b) {
            mpz_ui_pow_ui(exp.get_mpz_t(), a, b);
            sum = digital_sum(exp);
            if (sum > max) {
                max = sum;
            }
        }
    }
    std::cout << max << std::endl;
    timer.print_elapsed();
}
#+end_src

#+RESULTS:
: 972
: 5 ms

* DONE p57
CLOSED: [2019-01-31 Thu 01:02]
#+begin_src C++ :libs "-lgmpxx -lgmp"
#include <iostream>
#include <gmpxx.h>
#include <timer.h>

int main () {
    Timer timer;
    timer.start();
    mpz_class top = 3;
    mpz_class bot = 2;
    int count = 0;
    for (int i = 0; i < 1000; ++i) {
        if (top.get_str().size() > bot.get_str().size()) {
            ++count;
        }
        mpz_class oldtop = top;
        top += 2*bot;
        bot += oldtop;
    }
    std::cout << count << std::endl;
    timer.print_elapsed();
}
#+end_src

#+RESULTS:
: 153
: 2 ms

* p58
#+begin_src C++
#include <iostream>

int spiral(double goal_r) {
}
#+end_src
* DONE p67
CLOSED: [2018-09-06 Thu 22:22]
#+begin_src C++
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <timer.h>

typedef std::vector<std::vector<int>> triangle;

int main () {
    Timer timer;
    timer.start();
    triangle v;
    int a;
    std::ifstream f("data/p67-triangle.txt");
    for (int line = 0; line < 100; ++line) {
        std::vector<int> l;
        for (int elem = 0; elem < line + 1; ++elem) {
            int num;
            f >> num;
            l.push_back(num);
        }
        v.push_back(l);
    }
    for (triangle::reverse_iterator it = v.rbegin() + 1; it < v.rend(); ++it) {
        for (int i = 0; i < it->size(); ++i) {
            (*it)[i] += std::max((*std::prev(it))[i],(*std::prev(it))[i+1]);
        }
    }
    std::cout << v[0][0] << '\n';
    timer.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 7273
: 0 ms

* TODO 71
#+begin_src C++ :flags "-O3 -lgmpxx -lgmp"
#include <iostream>
#include <set>
#include <gmpxx.h>

typedef mpq_class fraction;

std::ostream& operator<< (std::ostream &out, const mpq_class &q) {
    if (q.get_num() != q.get_den())
        if (q.get_num() % q.get_den() != 0) {
            out << q.get_num() << "/" << q.get_den();
        }
        else {
            out << mpz_class(q.get_num()/q.get_den());
        }
    else {
        out << 1;
    }
    return out;
}

std::ostream& operator<<(std::ostream &out, const __mpq_struct *s) {
    out << mpq_class(s);
    return out;
}

int main () {
    std::set<fraction> s;
    for (int d = 2; d <= 10000; ++d) {
        for (int n = 1; n < d; ++n) {
            fraction f{n,d};
            f.canonicalize();
            s.insert(f);
        }
    }
    // for (const auto elem : s) {
    //     std::cout << elem << ' ';
    // }
    // std::cout << '\n';
    // std::cout << *std::prev(s.find(fraction(3,7))) << '\n';

    return 0;
}
#+end_src

#+RESULTS:
: 428/999

* TODO 81
Similar to 39?

* DONE p92
CLOSED: [2018-09-06 Thu 23:32]
#+begin_src C++
#include <iostream>
#include <cmath>
#include <numbers.h>
#include <timer.h>

int digit_square_sum(int n) {
    int pow = 0;
    int res = 0;
    while (std::pow(10,pow) <= n) {
        int digit = nth_digit(n, pow);
        res += digit*digit;
        ++pow;
    }
    return res;
}

bool reaches_89(int n) {
    int sum;
    do {
        sum = digit_square_sum(n);
        n = sum;
    } while (sum != 89 && sum != 1);
    return (sum == 89) ? true : false;
}

int main () {
    Timer t;
    t.start();
    int reached_count = 0;
    for (int i = 1; i < 10000000; ++i) {
        if (reaches_89(i)) {
            ++reached_count;
        }
    }
    std::cout << reached_count;
    t.print_elapsed();
    return 0;
}
#+end_src

#+RESULTS:
: 16866 ms
: 8581146

* TODO 94
#+begin_src C++
#include <iostream>
#include <cmath>
#include <array>
#include "/home/dieggsy/src/project-euler/timer.h"

class AETriangle {
    long m_perimeter;
    double m_area;
    std::array<long, 3> m_sides;
public:
    AETriangle() {}
    AETriangle(long a, int add) {
        long b = a;
        long c = a + add;
        m_sides = {a, b, c};
        m_perimeter = a + b + c;
        double s = double(m_perimeter)/2;
        m_area = std::sqrt(s*(s-a)*(s-b)*(s-c));
    }
    long perimeter() {
        return m_perimeter;
    }
    double area() {
        return m_area;
    }
    std::array<long, 3>& sides() {
        return m_sides;
    }
};

int main () {
    Timer timer;
    timer.start();
    AETriangle t;
    long total = 0;
    int side_length = 1;
    do {
        t = AETriangle(side_length,1);
        double area = t.area();
        if (std::trunc(area) == area && area != 0) {
            // std::array<long,3> &sides = t.sides();
            // std::cout << sides[0] << ' ' << sides[1] << ' ' << sides[2] << ' ' << t.perimeter()<< ' ' << area;
            // std::cout << '\n';
            total += t.perimeter();
        }
        ++side_length;
    } while (t.perimeter() < 1000000000);
    timer.print_elapsed();
    std::cout << total << '\n';
    return 0;
}
#+end_src

#+RESULTS:
: 1714 ms
: 156265903712058790

* TODO 112
#+begin_src C++
#include <iostream>
#include <cmath>
#include <algorithm>
#include <numeric>

class Fraction {
    long _numerator;
    long _denominator;

    void simplify() {
        long d = std::gcd(_numerator, _denominator);
        _numerator /= d;
        _denominator /=d;
    }
public:
    Fraction(long num, long den) {
        _numerator = num;
        _denominator = den;
        simplify();
    }
    long numerator () {
        return _numerator;
    }
    long denominator () {
        return _denominator;
    }

    friend Fraction operator+(const Fraction f1, const Fraction f2);
    friend Fraction operator+(const long n, const Fraction f);
    friend Fraction operator+(const Fraction f, const long n);
    friend bool operator==(const Fraction f1, const Fraction f2);
    friend bool operator!=(const Fraction f1, const Fraction f2);
    friend std::ostream& operator<< (std::ostream &out, const Fraction &fraction);
};

Fraction operator+(const Fraction f1, const Fraction f2) {
    long den = std::lcm(f1._denominator, f2._denominator);
    long num = f1._numerator * den/f1._denominator + f2._numerator * den/f2._denominator;
    Fraction result = Fraction(num,den);
    result.simplify();
    return result;
}

Fraction operator+(const long n, const Fraction f) {
    return f + Fraction(n,1);
}

Fraction operator+(const Fraction f, const long n) {
    return n + f;
}

bool operator==(const Fraction f1, const Fraction f2) {
    return f1._numerator == f2._numerator && f1._denominator == f2._denominator;
}

bool operator!=(const Fraction f1, const Fraction f2) {
    return !(f1 == f2);
}

std::ostream& operator<< (std::ostream &out, const Fraction &f) {
    // Since operator<< is a friend of the Point class, we can access Point's members directly.
    if (f._numerator != f._denominator)
        if (f._numerator % f._denominator != 0) {
            out << f._numerator << "/" << f._denominator;
        }
        else {
            out << (f._numerator / f._denominator);
        }
    else {
        out << 1;
    }
    return out;
}

int nth_digit(int m, int n) {
    return ((m % static_cast<int>(std::pow(10,n + 1))) - (m % static_cast<int>(std::pow(10, n))))
        / static_cast<int>(std::pow(10, n));
}

bool bouncy(long n) {
    if (n < 100) {
        return false;
    }
    int i = 1;
    bool inc = false;
    bool dec = false;

    while (! (std::pow(10, i) > n)) {
        // std::cout << nth_digit(n,i)
        //           << nth_digit(n,i-1)
        //           << '\n';
        if (nth_digit(n,i) > nth_digit(n,i-1)) {
            // std::cout << "INC" << '\n';
            inc = true;
        }
        else if (nth_digit(n,i) <= nth_digit(n,i-1)) {
            // std::cout << "DEC" << '\n';
            dec = true;
        }
        ++i;
    }
    // std::cout << inc << '\n';
    // std::cout << dec << '\n';
    return !(inc ^ dec);
}


int main () {
    long b = 0;
    long total = 0;
    long n = 1;
    do {
        if (bouncy(n)) {
                ++b;
        }
        ++total;
    } while(Fraction(b,total) != Fraction(1,2));
    std::cout << b << ' ' << total;
    std::cout << Fraction(0,1) << '\n';
    return 0;
}
#+end_src

#+RESULTS:

* SLOW 206
#+begin_src C++
#include <iostream>
#include <cmath>
// #include <regex>
// #include <string>

long nth_digit(long m, long n) {
    return ((m % static_cast<long>(std::pow(10,n + 1))) - (m % static_cast<long>(std::pow(10, n))))
        / static_cast<long>(std::pow(10, n));
}

bool meets_criteria_p (long number) {
    // std::cout << number << std::endl;
    for (int i=2, j=9; i <= 18; i += 2, --j) {
        std::cout << number << ' ' << i << ' ' << nth_digit(number,i) << ' ' << j << '\n';
        // if (nth_digit(number,i) != j) {
        //     return false;
        // }
    }
    return nth_digit(number,0) == 0;
}

int main () {
    long i = 1010101010;
    // long i = 1000000000;
    // std::regex re {"1\\d2\\d3\\d4\\d5\\d6\\d7\\d8\\d9\\d0"};
    // while (!std::regex_match(std::to_string(i*i), re)) {
    //     ++i;
    // }

    // while(!meets_criteria_p(i*i)) {
    //     ++i;
    // }
    // std::cout << i << '\n';
    // std::cout << nth_digit(1234,0) << std::endl;
    std::cout << meets_criteria_p(1929374254627488900) << '\n';
    // std::cout << nth_digit(1929374254627488900,14);
    return 0;
}
#+end_src

#+RESULTS:
#+begin_example
1929374254627488900 2 9 9
1929374254627488900 4 8 8
1929374254627488900 6 7 7
1929374254627488900 8 6 6
1929374254627488900 10 5 5
1929374254627488900 12 4 4
1929374254627488900 14 2 3
1929374254627488900 16 2 2
1929374254627488900 18 1 1
1
#+end_example
